<?php
/**
* All bridge logic
* Note : adapter are store in other place
*/

interface BridgeInterface{
    public function collectData(array $param);
    public function getName();
    public function getURI();
    public function getCacheDuration();
}

abstract class BridgeAbstract implements BridgeInterface{
    protected $cache;
    protected $items = array();

    /**
    * Launch probative exception
    */
    protected function returnError($message, $code){
        throw new \HttpException($message, $code);
    }

    /**
    * Return datas store in the bridge
    * @return mixed
    */
    public function getDatas(){
        return $this->items;
    }

    /**
    * Defined datas with parameters depending choose bridge
    * Note : you can defined a cache before with "setCache"
    * @param array $param $_REQUEST, $_GET, $_POST, or array with bridge expected paramters
    */
    public function setDatas(array $param){
        if( !is_null($this->cache) ){
            $this->cache->prepare($param);
            $time = $this->cache->getTime();
        }
        else{
            $time = false; // No cache ? No time !
        }

        if( $time !== false && ( time() - $this->getCacheDuration() < $time ) ){ // Cache file has not expired. Serve it.
            $this->items = $this->cache->loadData();
        }
        else{
            $this->collectData($param);

            if( !is_null($this->cache) ){ // Cache defined ? We go to refresh is memory :D
                $this->cache->saveData($this->getDatas());
            }
        }
    }

    /**
    * Define default duraction for cache
    */
    public function getCacheDuration(){
        return 3600;
    }

    /**
    * Defined cache object to use
    */
    public function setCache(\CacheAbstract $cache){
        $this->cache = $cache;

        return $this;
    }

    /**
     * Set default image SRC attribute to point on given server when none is provided (that's to say when image src starts with '/'
     */
    public function defaultImageSrcTo($content, $server) {
        foreach($content->find('img') as $image) {
            if(strpos($image->src, '/')==0) {
                $image->src = $server.$image->src;
            }
        }
    }
}

/**
 * Extension of BridgeAbstract allowing caching of files downloaded over http files.
 * This is specially useful for sites from Gawker or Liberation networks, which allow pages excerpts top be viewed together on index, while full pages have to be downloaded
 * separately.
 * This class mainly provides a get_cached method which will will download the file from its remote location.
 * TODO allow file cache invalidation by touching files on access, and removing files/directories which have not been touched since ... a long time
 * After all, rss-bridge is not respaw, isn't it ?
 */
abstract class HttpCachingBridgeAbstract extends BridgeAbstract {
    
    /**
     * Maintain locally cached versions of pages to download to avoid multiple doiwnloads.
     * A file name is generated by replacing all "/" by "_", and the file is saved below this bridge cache
     * @param url url to cache
     * @return content of file as string
     */
    public function get_cached($url) {
        $simplified_url = str_replace(["http://", "https://", "?", "&", "="], ["", "", "/", "/", "/"], $url);
		// TODO build this from the variable given to Cache
		$pageCacheDir = __DIR__ . '/../cache/'."pages/";
        $filename =  $pageCacheDir.$simplified_url;
        if (substr($filename, -1) == '/') {
            $filename = $filename."index.html";
        }
        if(file_exists($filename)) {
//            $this->message("loading cached file from ".$filename." for page at url ".$url);
			// TODO touch file and its parent, and try to do neighbour deletion
            $this->refresh_in_cache($pageCacheDir, $filename);
		} else {
//            $this->message("we have no local copy of ".$url." Downloading to ".$filename);
            $dir = substr($filename, 0, strrpos($filename, '/'));
            if(!is_dir($dir)) {
//				$this->message("creating directories for ".$dir);
                mkdir($dir, 0777, true);
            }
            $this->download_remote($url, $filename);
        }
        return file_get_contents($filename);
    }
    
    private function refresh_in_cache($pageCacheDir, $filename) {
		$currentPath = $filename;
		while(!$pageCacheDir==$currentPath) {
			touch($currentPath);
			$currentPath = dirname($currentPath);
		}
    }

    public function download_remote($url , $save_path) {
        $f = fopen( $save_path , 'w+');
        if($f) {
            $handle = fopen($url , "rb");
            if($handle) {
                while (!feof($handle)) {
                    $contents = fread($handle, 8192);
                    if($contents) {
                        fwrite($f , $contents);
                    }
                }
                fclose($handle);
            }
            fclose($f);
        }
    }
    
    public function remove_from_cache($url) {
        $simplified_url = str_replace(["http://", "https://", "?", "&", "="], ["", "", "/", "/", "/"], $url);
    	// TODO build this from the variable given to Cache
		$pageCacheDir = __DIR__ . '/../cache/'."pages/";
        $filename =  realpath($pageCacheDir.$simplified_url);
        $this->message("removing from cache \"".$filename."\" WELL, NOT REALLY");
        // filename is NO GOOD
//        unlink($filename);
    }
    
    public function message($text) {
        $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3);
        $calling = $backtrace[2];
        $message = $calling["file"].":".$calling["line"]
            ." class ".get_class($this)."->".$calling["function"]
            ." - ".$text;
        error_log($message);
    }
}

class Bridge{

    static protected $dirBridge;

    public function __construct(){
        throw new \LogicException('Please use ' . __CLASS__ . '::create for new object.');
    }

    /**
    * Create a new bridge object
    * @param string $nameBridge Defined bridge name you want use
    * @return Bridge object dedicated
    */
    static public function create($nameBridge){
        if( !static::isValidNameBridge($nameBridge) ){
            throw new \InvalidArgumentException('Name bridge must be at least one uppercase follow or not by alphanumeric or dash characters.');
        }

        $pathBridge = self::getDir() . $nameBridge . '.php';
        
        if( !file_exists($pathBridge) ){
            throw new \Exception('The bridge you looking for does not exist. It should be at path '.$pathBridge);
        }

        require_once $pathBridge;

        return new $nameBridge();
    }

    static public function setDir($dirBridge){
        if( !is_string($dirBridge) ){
            throw new \InvalidArgumentException('Dir bridge must be a string.');
        }

        if( !file_exists($dirBridge) ){
            throw new \Exception('Dir bridge does not exist.');
        }

        self::$dirBridge = $dirBridge;
    }

    static public function getDir(){
        $dirBridge = self::$dirBridge;

        if( is_null($dirBridge) ){
            throw new \LogicException(__CLASS__ . ' class need to know bridge path !');
        }

        return $dirBridge;
    }

    static public function isValidNameBridge($nameBridge){
        return preg_match('@^[A-Z][a-zA-Z0-9-]*$@', $nameBridge);
    }

    /**
    * Read bridge dir and catch informations about each bridge depending annotation
    * @return array Informations about each bridge
    */
    static public function searchInformation(){
        $pathDirBridge = self::getDir();

        $listBridge = array();

        $searchCommonPattern = array('maintainer', 'description', 'homepage', 'name');

        $dirFiles = scandir($pathDirBridge);
        if( $dirFiles !== false ){
            foreach( $dirFiles as $fileName ){
                if( preg_match('@([^.]+)\.php@U', $fileName, $out) ){ // Is PHP file ?
                    $infos = array(); // Information about the bridge
                    $resParse = token_get_all(file_get_contents($pathDirBridge . $fileName)); // Parse PHP file
                    foreach($resParse as $v){
                        if( is_array($v) && $v[0] == T_DOC_COMMENT ){ // Lexer node is COMMENT ?
                            $commentary = $v[1];
                            foreach( $searchCommonPattern as $name){ // Catch information with common pattern
                                preg_match('#@' . preg_quote($name, '#') . '\s+(.+)#', $commentary, $outComment);
                                if( isset($outComment[1]) ){
                                    $infos[$name] = $outComment[1];
                                }
                            }

                            preg_match_all('#@use(?<num>[1-9][0-9]*)\s?\((?<args>.+)\)(?:\r|\n)#', $commentary, $outComment); // Catch specific information about "use".
                            if( isset($outComment['args']) && is_array($outComment['args']) ){
                                $infos['use'] = array();
                                foreach($outComment['args'] as $num => $args){ // Each use
                                    preg_match_all('#(?<name>[a-z]+)="(?<value>.*)"(?:,|$)#U', $args, $outArg); // Catch arguments for current use
                                    if( isset($outArg['name']) ){
                                        $usePos = $outComment['num'][$num]; // Current use name
                                        if( !isset($infos['use'][$usePos]) ){ // Not information actually for this "use" ?
                                            $infos['use'][$usePos] = array();
                                        }

                                        foreach($outArg['name'] as $numArg => $name){ // Each arguments
                                            $infos['use'][$usePos][$name] = $outArg['value'][$numArg];
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if( isset($infos['name']) ){ // If informations containt at least a name
                        $listBridge[$out[1]] = $infos;
                    }
                }
            }
        }

        return $listBridge;
    }
}
